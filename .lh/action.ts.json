{
    "sourceFile": "action.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 17,
            "patches": [
                {
                    "date": 1745283152051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745283231257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,9 @@\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n   for (const action of yield* each(fd)) {\n     console.log(\"take a2\", action);\n+    yield* each.next();\n     return action;\n   }\n \n   return { type: \"take failed, this should not be possible\" };\n"
                },
                {
                    "date": 1745283310675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,8 @@\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n   for (const action of yield* each(fd)) {\n     console.log(\"take a2\", action);\n-    yield* each.next();\n     return action;\n   }\n \n   return { type: \"take failed, this should not be possible\" };\n"
                },
                {
                    "date": 1745283812673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,14 @@\n ): Operation<ActionWithPayload<P>>;\n export function* take(pattern: ActionPattern): Operation<Action> {\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n-  for (const action of yield* each(fd)) {\n+\n+  // Get the first action from the stream\n+  const iterator = yield* each(fd);\n+  const { value: action, done } = iterator.next();\n+\n+  if (!done && action) {\n     console.log(\"take a2\", action);\n     return action;\n   }\n \n"
                },
                {
                    "date": 1745283834303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,13 +61,10 @@\n export function* take(pattern: ActionPattern): Operation<Action> {\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n \n-  // Get the first action from the stream\n-  const iterator = yield* each(fd);\n-  const { value: action, done } = iterator.next();\n-\n-  if (!done && action) {\n+  // In Effection v4, each returns an iterable that we need to iterate through\n+  for (const action of yield* each(fd)) {\n     console.log(\"take a2\", action);\n     return action;\n   }\n \n"
                },
                {
                    "date": 1745283844046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n   pattern: ActionPattern,\n   op: (action: AnyAction) => Operation<T>,\n ) {\n   const fd = useActions(pattern);\n-  let lastTask;\n+  let lastTask: Task | undefined;\n \n   for (const action of yield* each(fd)) {\n     if (lastTask) {\n       yield* lastTask.halt();\n"
                },
                {
                    "date": 1745283851595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n   type Signal,\n   SignalQueueFactory,\n   spawn,\n   type Stream,\n+  type Task,\n } from \"effection\";\n import { ActionPattern, matcher } from \"./matcher.ts\";\n import type { Action, ActionWithPayload, AnyAction } from \"./types.ts\";\n import { createFilterQueue } from \"./queue.ts\";\n"
                },
                {
                    "date": 1745283859780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n   pattern: ActionPattern,\n   op: (action: AnyAction) => Operation<T>,\n ) {\n   const fd = useActions(pattern);\n-  let lastTask: Task | undefined;\n+  let lastTask: Task<T> | undefined;\n \n   for (const action of yield* each(fd)) {\n     if (lastTask) {\n       yield* lastTask.halt();\n"
                },
                {
                    "date": 1745284002549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,11 +63,20 @@\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n \n   // In Effection v4, each returns an iterable that we need to iterate through\n-  for (const action of yield* each(fd)) {\n-    console.log(\"take a2\", action);\n-    return action;\n+  const iterator = yield* each(fd);\n+\n+  // Get the first action from the stream\n+  const result = iterator.next();\n+\n+  if (!result.done && result.value) {\n+    console.log(\"take a2\", result.value);\n+\n+    // Advance the iterator to allow future takes to work\n+    yield* each.next();\n+\n+    return result.value;\n   }\n \n   return { type: \"take failed, this should not be possible\" };\n }\n"
                },
                {
                    "date": 1745284015355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,20 +63,15 @@\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n \n   // In Effection v4, each returns an iterable that we need to iterate through\n-  const iterator = yield* each(fd);\n+  for (const action of yield* each(fd)) {\n+    console.log(\"take a2\", action);\n \n-  // Get the first action from the stream\n-  const result = iterator.next();\n-\n-  if (!result.done && result.value) {\n-    console.log(\"take a2\", result.value);\n-\n     // Advance the iterator to allow future takes to work\n     yield* each.next();\n \n-    return result.value;\n+    return action;\n   }\n \n   return { type: \"take failed, this should not be possible\" };\n }\n"
                },
                {
                    "date": 1745284137538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,9 +63,12 @@\n   const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n \n   // In Effection v4, each returns an iterable that we need to iterate through\n-  for (const action of yield* each(fd)) {\n+  const iterator = yield* each(fd);\n+  const { value: action, done } = iterator.next();\n+\n+  if (!done && action) {\n     console.log(\"take a2\", action);\n \n     // Advance the iterator to allow future takes to work\n     yield* each.next();\n"
                },
                {
                    "date": 1745284156445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,11 +64,11 @@\n   console.log(\"take a1\", pattern);\n \n   // In Effection v4, each returns an iterable that we need to iterate through\n   const iterator = yield* each(fd);\n-  const { value: action, done } = iterator.next();\n \n-  if (!done && action) {\n+  // Use a for...of loop to get the first action\n+  for (const action of iterator) {\n     console.log(\"take a2\", action);\n \n     // Advance the iterator to allow future takes to work\n     yield* each.next();\n"
                },
                {
                    "date": 1745284535191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,25 +59,30 @@\n export function take<P>(\n   pattern: ActionPattern,\n ): Operation<ActionWithPayload<P>>;\n export function* take(pattern: ActionPattern): Operation<Action> {\n-  const fd = useActions(pattern);\n+  // Get the actions signal from the context\n+  const actions = yield* ActionContext.expect();\n+  const match = matcher(pattern);\n   console.log(\"take a1\", pattern);\n \n-  // In Effection v4, each returns an iterable that we need to iterate through\n-  const iterator = yield* each(fd);\n+  // Create a promise that will resolve when a matching action is received\n+  const { promise, resolve } = yield* withResolvers<Action>();\n \n-  // Use a for...of loop to get the first action\n-  for (const action of iterator) {\n-    console.log(\"take a2\", action);\n+  // Set up a one-time listener for the next matching action\n+  const listener = (action: AnyAction) => {\n+    if (match(action)) {\n+      console.log(\"take a2\", action);\n+      resolve(action);\n+      actions.unsubscribe(listener);\n+    }\n+  };\n \n-    // Advance the iterator to allow future takes to work\n-    yield* each.next();\n+  // Subscribe to the actions signal\n+  actions.subscribe(listener);\n \n-    return action;\n-  }\n-\n-  return { type: \"take failed, this should not be possible\" };\n+  // Wait for the promise to resolve with the matching action\n+  return yield* promise;\n }\n \n export function* takeEvery<T>(\n   pattern: ActionPattern,\n"
                },
                {
                    "date": 1745284543282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n   SignalQueueFactory,\n   spawn,\n   type Stream,\n   type Task,\n+  withResolvers,\n } from \"effection\";\n import { ActionPattern, matcher } from \"./matcher.ts\";\n import type { Action, ActionWithPayload, AnyAction } from \"./types.ts\";\n import { createFilterQueue } from \"./queue.ts\";\n"
                },
                {
                    "date": 1745284555543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,30 +60,22 @@\n export function take<P>(\n   pattern: ActionPattern,\n ): Operation<ActionWithPayload<P>>;\n export function* take(pattern: ActionPattern): Operation<Action> {\n-  // Get the actions signal from the context\n-  const actions = yield* ActionContext.expect();\n-  const match = matcher(pattern);\n+  const fd = useActions(pattern);\n   console.log(\"take a1\", pattern);\n \n-  // Create a promise that will resolve when a matching action is received\n-  const { promise, resolve } = yield* withResolvers<Action>();\n+  // In Effection v4, each returns an iterable that we need to iterate through\n+  for (const action of yield* each(fd)) {\n+    console.log(\"take a2\", action);\n \n-  // Set up a one-time listener for the next matching action\n-  const listener = (action: AnyAction) => {\n-    if (match(action)) {\n-      console.log(\"take a2\", action);\n-      resolve(action);\n-      actions.unsubscribe(listener);\n-    }\n-  };\n+    // Advance the iterator to allow future takes to work\n+    yield* each.next();\n \n-  // Subscribe to the actions signal\n-  actions.subscribe(listener);\n+    return action;\n+  }\n \n-  // Wait for the promise to resolve with the matching action\n-  return yield* promise;\n+  return { type: \"take failed, this should not be possible\" };\n }\n \n export function* takeEvery<T>(\n   pattern: ActionPattern,\n"
                },
                {
                    "date": 1745284563839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n   SignalQueueFactory,\n   spawn,\n   type Stream,\n   type Task,\n-  withResolvers,\n } from \"effection\";\n import { ActionPattern, matcher } from \"./matcher.ts\";\n import type { Action, ActionWithPayload, AnyAction } from \"./types.ts\";\n import { createFilterQueue } from \"./queue.ts\";\n"
                },
                {
                    "date": 1745285874859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -150,5 +150,8 @@\n   const fn = (payload?: unknown) => ({\n     type: actionType,\n     payload,\n   });\n-  fn.to\n\\ No newline at end of file\n+  fn.toString = () => actionType;\n+\n+  return fn;\n+}\n"
                },
                {
                    "date": 1745287207858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,163 @@\n+import {\n+  call,\n+  createContext,\n+  createSignal,\n+  each,\n+  type Operation,\n+  type Signal,\n+  SignalQueueFactory,\n+  spawn,\n+  type Stream,\n+  type Task,\n+  withResolvers,\n+} from \"effection\";\n+import { ActionPattern, matcher } from \"./matcher.ts\";\n+import type { Action, ActionWithPayload, AnyAction } from \"./types.ts\";\n+import { createFilterQueue } from \"./queue.ts\";\n+import { ActionFnWithPayload } from \"./types.ts\";\n+\n+export const ActionContext = createContext(\n+  \"starfx:action\",\n+  createSignal<AnyAction, void>(),\n+);\n+\n+export function useActions(pattern: ActionPattern): Stream<AnyAction, void> {\n+  return {\n+    [Symbol.iterator]: function* () {\n+      const actions = yield* ActionContext.expect();\n+      const match = matcher(pattern);\n+      yield* SignalQueueFactory.set(() => createFilterQueue(match) as any);\n+      return yield* actions;\n+    },\n+  };\n+}\n+\n+export function emit({\n+  signal,\n+  action,\n+}: {\n+  signal: Signal<AnyAction, void>;\n+  action: AnyAction | AnyAction[];\n+}) {\n+  if (Array.isArray(action)) {\n+    if (action.length === 0) {\n+      return;\n+    }\n+    action.map((a) => signal.send(a));\n+  } else {\n+    signal.send(action);\n+  }\n+}\n+\n+export function* put(action: AnyAction | AnyAction[]) {\n+  const signal = yield* ActionContext.expect();\n+  return emit({\n+    signal,\n+    action,\n+  });\n+}\n+\n+export function take<P>(\n+  pattern: ActionPattern,\n+): Operation<ActionWithPayload<P>>;\n+export function* take(pattern: ActionPattern): Operation<Action> {\n+  const fd = useActions(pattern);\n+  console.log(\"take a1\", pattern);\n+  const a = yield* each(fd);\n+  yield* each.next();\n+  const firstAction = a[Symbol.iterator]().next().value;\n+  return firstAction;\n+\n+\n+  // // In Effection v4, each returns an iterable that we need to iterate through\n+  // for (const action of yield* each(fd)) {\n+  //   console.log(\"take a2\", action);\n+\n+  //   // Advance the iterator to allow future takes to work\n+  //   yield* each.next();\n+\n+  //   // Return the action and exit the loop\n+  //   return action;\n+  // }\n+\n+  // return { type: \"take failed, this should not be possible\" };\n+}\n+\n+export function* takeEvery<T>(\n+  pattern: ActionPattern,\n+  op: (action: AnyAction) => Operation<T>,\n+) {\n+  const fd = useActions(pattern);\n+  for (const action of yield* each(fd)) {\n+    yield* spawn(() => op(action));\n+    yield* each.next();\n+  }\n+}\n+\n+export function* takeLatest<T>(\n+  pattern: ActionPattern,\n+  op: (action: AnyAction) => Operation<T>,\n+) {\n+  const fd = useActions(pattern);\n+  let lastTask: Task<T> | undefined;\n+\n+  for (const action of yield* each(fd)) {\n+    if (lastTask) {\n+      yield* lastTask.halt();\n+    }\n+    lastTask = yield* spawn(() => op(action));\n+    yield* each.next();\n+  }\n+}\n+\n+export function* takeLeading<T>(\n+  pattern: ActionPattern,\n+  op: (action: AnyAction) => Operation<T>,\n+) {\n+  while (true) {\n+    const action = yield* take(pattern);\n+    yield* call(() => op(action));\n+  }\n+}\n+\n+export function* waitFor(\n+  predicate: Operation<boolean>,\n+) {\n+  const init = yield* predicate;\n+  if (init) {\n+    return;\n+  }\n+\n+  while (true) {\n+    yield* take(\"*\");\n+    const result = yield* predicate;\n+    if (result) {\n+      return;\n+    }\n+  }\n+}\n+\n+export function getIdFromAction(\n+  action: ActionWithPayload<{ key: string }> | ActionFnWithPayload,\n+): string {\n+  return typeof action === \"function\" ? action.toString() : action.payload.key;\n+}\n+\n+export const API_ACTION_PREFIX = \"\";\n+\n+export function createAction(actionType: string): () => Action;\n+export function createAction<P>(\n+  actionType: string,\n+): (p: P) => ActionWithPayload<P>;\n+export function createAction(actionType: string) {\n+  if (!actionType) {\n+    throw new Error(\"createAction requires non-empty string\");\n+  }\n+  const fn = (payload?: unknown) => ({\n+    type: actionType,\n+    payload,\n+  });\n+  fn.toString = () => actionType;\n+\n+  return fn;\n+}\n"
                }
            ],
            "date": 1745283152051,
            "name": "Commit-0",
            "content": "import {\n  call,\n  createContext,\n  createSignal,\n  each,\n  type Operation,\n  type Signal,\n  SignalQueueFactory,\n  spawn,\n  type Stream,\n} from \"effection\";\nimport { ActionPattern, matcher } from \"./matcher.ts\";\nimport type { Action, ActionWithPayload, AnyAction } from \"./types.ts\";\nimport { createFilterQueue } from \"./queue.ts\";\nimport { ActionFnWithPayload } from \"./types.ts\";\n\nexport const ActionContext = createContext(\n  \"starfx:action\",\n  createSignal<AnyAction, void>(),\n);\n\nexport function useActions(pattern: ActionPattern): Stream<AnyAction, void> {\n  return {\n    [Symbol.iterator]: function* () {\n      const actions = yield* ActionContext.expect();\n      const match = matcher(pattern);\n      yield* SignalQueueFactory.set(() => createFilterQueue(match) as any);\n      return yield* actions;\n    },\n  };\n}\n\nexport function emit({\n  signal,\n  action,\n}: {\n  signal: Signal<AnyAction, void>;\n  action: AnyAction | AnyAction[];\n}) {\n  if (Array.isArray(action)) {\n    if (action.length === 0) {\n      return;\n    }\n    action.map((a) => signal.send(a));\n  } else {\n    signal.send(action);\n  }\n}\n\nexport function* put(action: AnyAction | AnyAction[]) {\n  const signal = yield* ActionContext.expect();\n  return emit({\n    signal,\n    action,\n  });\n}\n\nexport function take<P>(\n  pattern: ActionPattern,\n): Operation<ActionWithPayload<P>>;\nexport function* take(pattern: ActionPattern): Operation<Action> {\n  const fd = useActions(pattern);\n  console.log(\"take a1\", pattern);\n  for (const action of yield* each(fd)) {\n    console.log(\"take a2\", action);\n    return action;\n  }\n\n  return { type: \"take failed, this should not be possible\" };\n}\n\nexport function* takeEvery<T>(\n  pattern: ActionPattern,\n  op: (action: AnyAction) => Operation<T>,\n) {\n  const fd = useActions(pattern);\n  for (const action of yield* each(fd)) {\n    yield* spawn(() => op(action));\n    yield* each.next();\n  }\n}\n\nexport function* takeLatest<T>(\n  pattern: ActionPattern,\n  op: (action: AnyAction) => Operation<T>,\n) {\n  const fd = useActions(pattern);\n  let lastTask;\n\n  for (const action of yield* each(fd)) {\n    if (lastTask) {\n      yield* lastTask.halt();\n    }\n    lastTask = yield* spawn(() => op(action));\n    yield* each.next();\n  }\n}\n\nexport function* takeLeading<T>(\n  pattern: ActionPattern,\n  op: (action: AnyAction) => Operation<T>,\n) {\n  while (true) {\n    const action = yield* take(pattern);\n    yield* call(() => op(action));\n  }\n}\n\nexport function* waitFor(\n  predicate: Operation<boolean>,\n) {\n  const init = yield* predicate;\n  if (init) {\n    return;\n  }\n\n  while (true) {\n    yield* take(\"*\");\n    const result = yield* predicate;\n    if (result) {\n      return;\n    }\n  }\n}\n\nexport function getIdFromAction(\n  action: ActionWithPayload<{ key: string }> | ActionFnWithPayload,\n): string {\n  return typeof action === \"function\" ? action.toString() : action.payload.key;\n}\n\nexport const API_ACTION_PREFIX = \"\";\n\nexport function createAction(actionType: string): () => Action;\nexport function createAction<P>(\n  actionType: string,\n): (p: P) => ActionWithPayload<P>;\nexport function createAction(actionType: string) {\n  if (!actionType) {\n    throw new Error(\"createAction requires non-empty string\");\n  }\n  const fn = (payload?: unknown) => ({\n    type: actionType,\n    payload,\n  });\n  fn.toString = () => actionType;\n\n  return fn;\n}\n"
        }
    ]
}