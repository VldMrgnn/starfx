{
    "sourceFile": "store/types.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1745282978773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1745282978773,
            "name": "Commit-0",
            "content": "import type { Patch } from \"../deps.ts\";\nimport type { Operation, Scope } from \"effection\";\nimport type { AnyAction, AnyState } from \"../types.ts\";\nimport type { LoaderOutput } from \"./slice/loaders.ts\";\nimport type { TableOutput } from \"./slice/table.ts\";\nimport { BaseCtx } from \"../mod.ts\";\nimport { createRun } from \"./run.ts\";\n\nexport type StoreUpdater<S extends AnyState> = (s: S) => S | void;\n\nexport type Listener = () => void;\n\nexport interface UpdaterCtx<S extends AnyState> extends BaseCtx {\n  updater: StoreUpdater<S> | StoreUpdater<S>[];\n  patches: Patch[];\n}\n\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\nexport interface BaseSchema<TOutput> {\n  initialState: TOutput;\n  schema: string;\n  name: string;\n}\n\nexport type Output<O extends { [key: string]: BaseSchema<unknown> }> = {\n  [key in keyof O]: O[key][\"initialState\"];\n};\n\nexport interface FxMap {\n  loaders: <M extends AnyState>(s: string) => LoaderOutput<M, AnyState>;\n  cache: (s: string) => TableOutput<any, AnyState>;\n  [key: string]: (name: string) => BaseSchema<unknown>;\n}\n\nexport type FxSchema<S extends AnyState, O extends FxMap = FxMap> =\n  & {\n    [key in keyof O]: ReturnType<O[key]>;\n  }\n  & { update: FxStore<S>[\"update\"] };\n\nexport interface FxStore<S extends AnyState> {\n  getScope: () => Scope;\n  getState: () => S;\n  subscribe: (fn: Listener) => () => void;\n  update: (u: StoreUpdater<S> | StoreUpdater<S>[]) => Operation<UpdaterCtx<S>>;\n  reset: (ignoreList?: (keyof S)[]) => Operation<UpdaterCtx<S>>;\n  run: ReturnType<typeof createRun>;\n  // deno-lint-ignore no-explicit-any\n  dispatch: (a: AnyAction | AnyAction[]) => any;\n  replaceReducer: (r: (s: S, a: AnyAction) => S) => void;\n  getInitialState: () => S;\n  // deno-lint-ignore no-explicit-any\n  [Symbol.observable]: () => any;\n}\n\nexport interface QueryState {\n  cache: TableOutput<any, any>[\"initialState\"];\n  loaders: LoaderOutput<any, any>[\"initialState\"];\n}\n"
        }
    ]
}