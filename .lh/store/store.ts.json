{
    "sourceFile": "store/store.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1745284453907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745284483990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,192 @@\n+import { createContext, createScope, createSignal, Ok, Scope } from \"../deps.ts\";\n+import { enablePatches, produceWithPatches } from \"../deps.ts\";\n+import { ActionContext, API_ACTION_PREFIX, emit } from \"../action.ts\";\n+import { BaseMiddleware, compose } from \"../compose.ts\";\n+import { StoreContext, StoreUpdateContext } from \"./context.ts\";\n+import { createRun } from \"./run.ts\";\n+import type { AnyAction, AnyState, Next } from \"../types.ts\";\n+import type { FxStore, Listener, StoreUpdater, UpdaterCtx } from \"./types.ts\";\n+const stubMsg = \"This is merely a stub, not implemented\";\n+\n+let id = 0;\n+\n+// https://github.com/reduxjs/redux/blob/4a6d2fb227ba119d3498a43fab8f53fe008be64c/src/createStore.ts#L344\n+function observable() {\n+  return {\n+    subscribe: (_observer: unknown) => {\n+      throw new Error(stubMsg);\n+    },\n+    [Symbol.observable]() {\n+      return this;\n+    },\n+  };\n+}\n+\n+export interface CreateStore<S extends AnyState> {\n+  scope?: Scope;\n+  initialState: S;\n+  middleware?: BaseMiddleware<UpdaterCtx<S>>[];\n+}\n+\n+export const IdContext = createContext(\"starfx:id\", 0);\n+\n+export function createStore<S extends AnyState>({\n+  initialState,\n+  scope: initScope,\n+  middleware = [],\n+}: CreateStore<S>): FxStore<S> {\n+  let scope: Scope;\n+  if (initScope) {\n+    scope = initScope;\n+  } else {\n+    scope = createScope();\n+  }\n+\n+  let state = initialState;\n+  const listeners = new Set<Listener>();\n+  enablePatches();\n+\n+  const signal = createSignal<AnyAction, void>();\n+  scope.set(ActionContext, signal);\n+  scope.set(IdContext, id++);\n+\n+  function getScope() {\n+    return scope;\n+  }\n+\n+  function getState() {\n+    return state;\n+  }\n+\n+  function subscribe(fn: Listener) {\n+    listeners.add(fn);\n+    return () => listeners.delete(fn);\n+  }\n+\n+  function* updateMdw(ctx: UpdaterCtx<S>, next: Next) {\n+    const upds: StoreUpdater<S>[] = [];\n+\n+    if (Array.isArray(ctx.updater)) {\n+      upds.push(...ctx.updater);\n+    } else {\n+      upds.push(ctx.updater);\n+    }\n+\n+    const [nextState, patches, _] = produceWithPatches(getState(), (draft) => {\n+      // TODO: check for return value inside updater\n+      // deno-lint-ignore no-explicit-any\n+      upds.forEach((updater) => updater(draft as any));\n+    });\n+    ctx.patches = patches;\n+\n+    // set the state!\n+    state = nextState;\n+\n+    yield* next();\n+  }\n+\n+  function* logMdw(ctx: UpdaterCtx<S>, next: Next) {\n+    dispatch({\n+      type: `${API_ACTION_PREFIX}store`,\n+      payload: ctx,\n+    });\n+    yield* next();\n+  }\n+\n+  function* notifyChannelMdw(_: UpdaterCtx<S>, next: Next) {\n+    const chan = yield* StoreUpdateContext.expect();\n+    yield* chan.send();\n+    yield* next();\n+  }\n+\n+  function* notifyListenersMdw(_: UpdaterCtx<S>, next: Next) {\n+    listeners.forEach((f) => f());\n+    yield* next();\n+  }\n+\n+  function createUpdater() {\n+    const fn = compose<UpdaterCtx<S>>([\n+      updateMdw,\n+      ...middleware,\n+      logMdw,\n+      notifyChannelMdw,\n+      notifyListenersMdw,\n+    ]);\n+\n+    return fn;\n+  }\n+\n+  const mdw = createUpdater();\n+  function* update(updater: StoreUpdater<S> | StoreUpdater<S>[]) {\n+    const ctx = {\n+      updater,\n+      patches: [],\n+      result: Ok(undefined),\n+    };\n+\n+    yield* mdw(ctx);\n+\n+    if (!ctx.result.ok) {\n+      dispatch({\n+        type: `${API_ACTION_PREFIX}store`,\n+        payload: ctx.result.error,\n+      });\n+    }\n+\n+    return ctx;\n+  }\n+\n+  function dispatch(action: AnyAction | AnyAction[]) {\n+    emit({ signal, action });\n+  }\n+\n+  function getInitialState() {\n+    return initialState;\n+  }\n+\n+  function* reset(ignoreList: (keyof S)[] = []) {\n+    return yield* update((s) => {\n+      const keep = ignoreList.reduce<S>(\n+        (acc, key) => {\n+          acc[key] = s[key];\n+          return acc;\n+        },\n+        { ...initialState },\n+      );\n+\n+      Object.keys(s).forEach((key: keyof S) => {\n+        s[key] = keep[key];\n+      });\n+    });\n+  }\n+\n+  const store = {\n+    getScope,\n+    getState,\n+    subscribe,\n+    update,\n+    reset,\n+    run: createRun(scope),\n+    // instead of actions relating to store mutation, they\n+    // refer to pieces of business logic -- that can also mutate state\n+    dispatch,\n+    // stubs so `react-redux` is happy\n+    // deno-lint-ignore no-explicit-any\n+    replaceReducer<S = any>(\n+      _nextReducer: (_s: S, _a: AnyAction) => void,\n+    ): void {\n+      throw new Error(stubMsg);\n+    },\n+    getInitialState,\n+    [Symbol.observable]: observable,\n+  };\n+\n+  // deno-lint-ignore no-explicit-any\n+  store.getScope().set(StoreContext, store as any);\n+  return store;\n+}\n+\n+/**\n+ * @deprecated use {@link createStore}\n+ */\n+export const configureStore = createStore;\n"
                },
                {
                    "date": 1745284495874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,10 @@\n   let scope: Scope;\n   if (initScope) {\n     scope = initScope;\n   } else {\n-    scope = createScope();\n+    const [newScope] = createScope();\n+    scope = newScope;\n   }\n \n   let state = initialState;\n   const listeners = new Set<Listener>();\n"
                },
                {
                    "date": 1745284503861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,9 @@\n     } else {\n       upds.push(ctx.updater);\n     }\n \n-    const [nextState, patches, _] = produceWithPatches(getState(), (draft) => {\n+    const [nextState, patches, _] = produceWithPatches(getState(), (draft: S) => {\n       // TODO: check for return value inside updater\n       // deno-lint-ignore no-explicit-any\n       upds.forEach((updater) => updater(draft as any));\n     });\n@@ -190,196 +190,4 @@\n /**\n  * @deprecated use {@link createStore}\n  */\n export const configureStore = createStore;\n-import { createContext, createScope, createSignal, Ok, Scope } from \"effection\";\n-import { enablePatches, produceWithPatches } from \"immer\";\n-import { ActionContext, API_ACTION_PREFIX, emit } from \"../action.ts\";\n-import { BaseMiddleware, compose } from \"../compose.ts\";\n-import { StoreContext, StoreUpdateContext } from \"./context.ts\";\n-import { createRun } from \"./run.ts\";\n-import type { AnyAction, AnyState, Next } from \"../types.ts\";\n-import type { FxStore, Listener, StoreUpdater, UpdaterCtx } from \"./types.ts\";\n-const stubMsg = \"This is merely a stub, not implemented\";\n-\n-let id = 0;\n-\n-// https://github.com/reduxjs/redux/blob/4a6d2fb227ba119d3498a43fab8f53fe008be64c/src/createStore.ts#L344\n-function observable() {\n-  return {\n-    subscribe: (_observer: unknown) => {\n-      throw new Error(stubMsg);\n-    },\n-    [Symbol.observable]() {\n-      return this;\n-    },\n-  };\n-}\n-\n-export interface CreateStore<S extends AnyState> {\n-  scope?: Scope;\n-  initialState: S;\n-  middleware?: BaseMiddleware<UpdaterCtx<S>>[];\n-}\n-\n-export const IdContext = createContext(\"starfx:id\", 0);\n-\n-export function createStore<S extends AnyState>({\n-  initialState,\n-  scope: initScope,\n-  middleware = [],\n-}: CreateStore<S>): FxStore<S> {\n-  let scope: Scope;\n-  if (initScope) {\n-    scope = initScope;\n-  } else {\n-    scope = createScope();\n-  }\n-\n-  let state = initialState;\n-  const listeners = new Set<Listener>();\n-  enablePatches();\n-\n-  const signal = createSignal<AnyAction, void>();\n-  scope.set(ActionContext, signal);\n-  scope.set(IdContext, id++);\n-\n-  function getScope() {\n-    return scope;\n-  }\n-\n-  function getState() {\n-    return state;\n-  }\n-\n-  function subscribe(fn: Listener) {\n-    listeners.add(fn);\n-    return () => listeners.delete(fn);\n-  }\n-\n-  function* updateMdw(ctx: UpdaterCtx<S>, next: Next) {\n-    const upds: StoreUpdater<S>[] = [];\n-\n-    if (Array.isArray(ctx.updater)) {\n-      upds.push(...ctx.updater);\n-    } else {\n-      upds.push(ctx.updater);\n-    }\n-\n-    const [nextState, patches, _] = produceWithPatches(getState(), (draft) => {\n-      // TODO: check for return value inside updater\n-      // deno-lint-ignore no-explicit-any\n-      upds.forEach((updater) => updater(draft as any));\n-    });\n-    ctx.patches = patches;\n-\n-    // set the state!\n-    state = nextState;\n-\n-    yield* next();\n-  }\n-\n-  function* logMdw(ctx: UpdaterCtx<S>, next: Next) {\n-    dispatch({\n-      type: `${API_ACTION_PREFIX}store`,\n-      payload: ctx,\n-    });\n-    yield* next();\n-  }\n-\n-  function* notifyChannelMdw(_: UpdaterCtx<S>, next: Next) {\n-    const chan = yield* StoreUpdateContext.expect();\n-    yield* chan.send();\n-    yield* next();\n-  }\n-\n-  function* notifyListenersMdw(_: UpdaterCtx<S>, next: Next) {\n-    listeners.forEach((f) => f());\n-    yield* next();\n-  }\n-\n-  function createUpdater() {\n-    const fn = compose<UpdaterCtx<S>>([\n-      updateMdw,\n-      ...middleware,\n-      logMdw,\n-      notifyChannelMdw,\n-      notifyListenersMdw,\n-    ]);\n-\n-    return fn;\n-  }\n-\n-  const mdw = createUpdater();\n-  function* update(updater: StoreUpdater<S> | StoreUpdater<S>[]) {\n-    const ctx = {\n-      updater,\n-      patches: [],\n-      result: Ok(undefined),\n-    };\n-\n-    yield* mdw(ctx);\n-\n-    if (!ctx.result.ok) {\n-      dispatch({\n-        type: `${API_ACTION_PREFIX}store`,\n-        payload: ctx.result.error,\n-      });\n-    }\n-\n-    return ctx;\n-  }\n-\n-  function dispatch(action: AnyAction | AnyAction[]) {\n-    emit({ signal, action });\n-  }\n-\n-  function getInitialState() {\n-    return initialState;\n-  }\n-\n-  function* reset(ignoreList: (keyof S)[] = []) {\n-    return yield* update((s) => {\n-      const keep = ignoreList.reduce<S>(\n-        (acc, key) => {\n-          acc[key] = s[key];\n-          return acc;\n-        },\n-        { ...initialState },\n-      );\n-\n-      Object.keys(s).forEach((key: keyof S) => {\n-        s[key] = keep[key];\n-      });\n-    });\n-  }\n-\n-  const store = {\n-    getScope,\n-    getState,\n-    subscribe,\n-    update,\n-    reset,\n-    run: createRun(scope),\n-    // instead of actions relating to store mutation, they\n-    // refer to pieces of business logic -- that can also mutate state\n-    dispatch,\n-    // stubs so `react-redux` is happy\n-    // deno-lint-ignore no-explicit-any\n-    replaceReducer<S = any>(\n-      _nextReducer: (_s: S, _a: AnyAction) => void,\n-    ): void {\n-      throw new Error(stubMsg);\n-    },\n-    getInitialState,\n-    [Symbol.observable]: observable,\n-  };\n-\n-  // deno-lint-ignore no-explicit-any\n-  store.getScope().set(StoreContext, store as any);\n-  return store;\n-}\n-\n-/**\n- * @deprecated use {@link createStore}\n- */\n-export const configureStore = createStore;\n"
                }
            ],
            "date": 1745284453907,
            "name": "Commit-0",
            "content": "import { createContext, createScope, createSignal, Ok, Scope } from \"effection\";\nimport { enablePatches, produceWithPatches } from \"immer\";\nimport { ActionContext, API_ACTION_PREFIX, emit } from \"../action.ts\";\nimport { BaseMiddleware, compose } from \"../compose.ts\";\nimport { StoreContext, StoreUpdateContext } from \"./context.ts\";\nimport { createRun } from \"./run.ts\";\nimport type { AnyAction, AnyState, Next } from \"../types.ts\";\nimport type { FxStore, Listener, StoreUpdater, UpdaterCtx } from \"./types.ts\";\nconst stubMsg = \"This is merely a stub, not implemented\";\n\nlet id = 0;\n\n// https://github.com/reduxjs/redux/blob/4a6d2fb227ba119d3498a43fab8f53fe008be64c/src/createStore.ts#L344\nfunction observable() {\n  return {\n    subscribe: (_observer: unknown) => {\n      throw new Error(stubMsg);\n    },\n    [Symbol.observable]() {\n      return this;\n    },\n  };\n}\n\nexport interface CreateStore<S extends AnyState> {\n  scope?: Scope;\n  initialState: S;\n  middleware?: BaseMiddleware<UpdaterCtx<S>>[];\n}\n\nexport const IdContext = createContext(\"starfx:id\", 0);\n\nexport function createStore<S extends AnyState>({\n  initialState,\n  scope: initScope,\n  middleware = [],\n}: CreateStore<S>): FxStore<S> {\n  let scope: Scope;\n  if (initScope) {\n    scope = initScope;\n  } else {\n    scope = createScope();\n  }\n\n  let state = initialState;\n  const listeners = new Set<Listener>();\n  enablePatches();\n\n  const signal = createSignal<AnyAction, void>();\n  scope.set(ActionContext, signal);\n  scope.set(IdContext, id++);\n\n  function getScope() {\n    return scope;\n  }\n\n  function getState() {\n    return state;\n  }\n\n  function subscribe(fn: Listener) {\n    listeners.add(fn);\n    return () => listeners.delete(fn);\n  }\n\n  function* updateMdw(ctx: UpdaterCtx<S>, next: Next) {\n    const upds: StoreUpdater<S>[] = [];\n\n    if (Array.isArray(ctx.updater)) {\n      upds.push(...ctx.updater);\n    } else {\n      upds.push(ctx.updater);\n    }\n\n    const [nextState, patches, _] = produceWithPatches(getState(), (draft) => {\n      // TODO: check for return value inside updater\n      // deno-lint-ignore no-explicit-any\n      upds.forEach((updater) => updater(draft as any));\n    });\n    ctx.patches = patches;\n\n    // set the state!\n    state = nextState;\n\n    yield* next();\n  }\n\n  function* logMdw(ctx: UpdaterCtx<S>, next: Next) {\n    dispatch({\n      type: `${API_ACTION_PREFIX}store`,\n      payload: ctx,\n    });\n    yield* next();\n  }\n\n  function* notifyChannelMdw(_: UpdaterCtx<S>, next: Next) {\n    const chan = yield* StoreUpdateContext.expect();\n    yield* chan.send();\n    yield* next();\n  }\n\n  function* notifyListenersMdw(_: UpdaterCtx<S>, next: Next) {\n    listeners.forEach((f) => f());\n    yield* next();\n  }\n\n  function createUpdater() {\n    const fn = compose<UpdaterCtx<S>>([\n      updateMdw,\n      ...middleware,\n      logMdw,\n      notifyChannelMdw,\n      notifyListenersMdw,\n    ]);\n\n    return fn;\n  }\n\n  const mdw = createUpdater();\n  function* update(updater: StoreUpdater<S> | StoreUpdater<S>[]) {\n    const ctx = {\n      updater,\n      patches: [],\n      result: Ok(undefined),\n    };\n\n    yield* mdw(ctx);\n\n    if (!ctx.result.ok) {\n      dispatch({\n        type: `${API_ACTION_PREFIX}store`,\n        payload: ctx.result.error,\n      });\n    }\n\n    return ctx;\n  }\n\n  function dispatch(action: AnyAction | AnyAction[]) {\n    emit({ signal, action });\n  }\n\n  function getInitialState() {\n    return initialState;\n  }\n\n  function* reset(ignoreList: (keyof S)[] = []) {\n    return yield* update((s) => {\n      const keep = ignoreList.reduce<S>(\n        (acc, key) => {\n          acc[key] = s[key];\n          return acc;\n        },\n        { ...initialState },\n      );\n\n      Object.keys(s).forEach((key: keyof S) => {\n        s[key] = keep[key];\n      });\n    });\n  }\n\n  const store = {\n    getScope,\n    getState,\n    subscribe,\n    update,\n    reset,\n    run: createRun(scope),\n    // instead of actions relating to store mutation, they\n    // refer to pieces of business logic -- that can also mutate state\n    dispatch,\n    // stubs so `react-redux` is happy\n    // deno-lint-ignore no-explicit-any\n    replaceReducer<S = any>(\n      _nextReducer: (_s: S, _a: AnyAction) => void,\n    ): void {\n      throw new Error(stubMsg);\n    },\n    getInitialState,\n    [Symbol.observable]: observable,\n  };\n\n  // deno-lint-ignore no-explicit-any\n  store.getScope().set(StoreContext, store as any);\n  return store;\n}\n\n/**\n * @deprecated use {@link createStore}\n */\nexport const configureStore = createStore;\n"
        }
    ]
}